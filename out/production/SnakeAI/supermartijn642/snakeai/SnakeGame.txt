package supermartijn642.snakeai;

import supermartijn642.nolearnneuralnetwork.NeuralNetwork;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Random;

/**
 * Created 2/1/2019 by SuperMartijn642
 */
public class SnakeGame {

    public final int xsize;
    public final int ysize;
    public final int snake_size;
    public final int food_amount;
    public final double min_distance_food;
    public final int viewWidth;

    public final BufferedImage screen;

    public SnakeGame(int xsize, int ysize, int snake_size, int food_amount, double min_distance_food, int viewWidth){
        this.xsize = xsize;
        this.ysize = ysize;
        this.snake_size = snake_size;
        this.food_amount = food_amount;
        this.min_distance_food = min_distance_food;
        this.viewWidth = viewWidth;
        this.screen = new BufferedImage(xsize + 2, ysize + 2, BufferedImage.TYPE_INT_ARGB);
    }

    public Result run(NeuralNetwork network, Random random, boolean log){

        // initialize
        ArrayList<Point> tale = new ArrayList<>(snake_size - 1);
        Point head = new Point((int)(xsize / 2D),(int)(ysize / 2D));
        ArrayList<Point> food = new ArrayList<>();
        placeFood(head,tale,food,random);
        String[] grid = new String[xsize * ysize];

        // start loop
        int score = 0;
        int updates = 0;
        loop: while(true){


            // network stuff
            double[] networkInput = createNetworkInputDistance(head,tale,food);
            double[] result = network.calculate(networkInput);
            for(double d : result)
                if(Double.isNaN(d))
                    System.out.println();
            if(log) {
                String[] inputString = new String[viewWidth];
                for(int y = 0; y < viewWidth; y++) {
                    for (int x = 0; x < viewWidth; x++) {
                        double value = networkInput[x * viewWidth + y];
                        if (inputString[y] == null)
                            inputString[y] = "{" + (value > 0 ? " " : "") + value;
                        else
                            inputString[y] += "," + (value > 0 ? " " : "") + value;
                    }
                    inputString[y] += "}";
                }
                System.out.println("input:");
                for(String s : inputString)
                    System.out.println("   " + s);
                System.out.println("result: {" + result[0] + "," + result[1] + "," + result[2] + "," + result[3] + "}");
            }


            // getting the heading
            int xHeading = 0;
            int yHeading = 0;
            if(result[0] > result[1] && result[0] > result[2] && result[0] > result[3])
                xHeading = -1;
            else if(result[1] > result[0] && result[1] > result[2] && result[1] > result[3])
                xHeading = 1;
            else if(result[2] > result[0] && result[2] > result[1] && result[2] > result[3])
                yHeading = -1;
            else if(result[3] > result[0] && result[3] > result[1] && result[3] > result[2])
                yHeading = 1;
            if(log) System.out.println("heading x: " + xHeading + " y: " + yHeading);


            // game logic
            if(tale.size() >= snake_size + score - 1)
                tale.remove(0);
            tale.add(head);
            head = new Point(head.x + xHeading, head.y + yHeading);
            if(head.x < 0 || head.x >= xsize || head.y < 0 || head.y >= ysize) {
                if(log) System.out.println("Death by wall! score: " + score + " updates: " + updates);
                break;
            }
            for(Point point : tale)
                if(point.equals(head)) {
                    if(log) System.out.println("Death by tale! score: " + score + " updates: " + updates);
                    break loop;
                }
            for(int a = 0; a < food.size(); a++) {
                if(food.get(a).equals(head)) {
                    food.remove(a);
                    a--;
                    score++;
                }
            }
            placeFood(head,tale,food,random);


            // logging
            if(log){
                for(int x = 0; x < xsize; x++)
                    for(int y = 0; y < ysize; y++)
                        grid[x * ysize + y] = "0";
                grid[head.x * ysize + head.y] = "X";
                for(Point point : tale)
                    grid[point.x * ysize + point.y] = "x";
                for(Point point : food)
                    grid[point.x * ysize + point.y] = "#";
                System.out.println("---------------------------------------------------");
                String[] gridtext = new String[ysize];
                for(int x = 0; x < xsize; x++){
                    for(int y = 0; y < ysize; y++){
                        String s = grid[x * ysize + y];
                        if(gridtext[y] == null)
                            gridtext[y] = s;
                        else
                            gridtext[y] += s;
                    }
                }
                for(String s : gridtext)
                    System.out.println("[" + s + " ]");
            }


            // update the updates
            if(updates >= 300 + score * 100)
                break;
            updates++;

            // update the screen
            this.updateScreen(head,tale,food);
        }
        double dist = food.get(0).distance(head);
        for(int a = 1; a < food.size(); a++)
            if(food.get(a).distance(head) < dist)
                dist = food.get(a).distance(head);
        return new Result(score + 1 - dist / Math.sqrt(xsize * xsize + ysize * ysize),updates);
    }

    private void placeFood(Point head, ArrayList<Point> tale, ArrayList<Point> food, Random random){
        loop: while(food.size() < food_amount) {
            Point point = new Point(random.nextInt(xsize), random.nextInt(ysize));
            if(point.distance(head) <= min_distance_food)
                continue;
            for(Point point1 : food)
                if(point.equals(point1))
                    continue loop;
            for(Point point1 : tale)
                if(point.equals(point1))
                    continue loop;
            food.add(point);
        }
    }

    private double[] createNetworkInputGridView(Point head, ArrayList<Point> tale, ArrayList<Point> food){
        double[] networkInput = new double[viewWidth * viewWidth];
        int center = (int)Math.floor(viewWidth / 2D);
        // setting default
        for(int a = 0; a < viewWidth * viewWidth; a++)
            networkInput[a] = 0.1;
        // head
        networkInput[center * viewWidth + center] = -5;
        // tale
        for(Point point : tale){
            int x = point.x - head.x + center;
            int y = point.y - head.y + center;
            if(x >= 0 && x < viewWidth && y >= 0 && y < viewWidth)
                networkInput[x * viewWidth + y] = -1;
        }
        // food
        for(Point point : food){
            int x = point.x - head.x + center;
            int y = point.y - head.y + center;
            if(x >= 0 && x < viewWidth && y >= 0 && y < viewWidth)
                networkInput[x * viewWidth + y] = 1;
        }
        // walls
        for(int x = 0; x + head.x - center < 0 && x < viewWidth; x++)
            for(int y = 0; y < viewWidth; y++)
                networkInput[x * viewWidth + y] = -1;
        for(int y = 0; y + head.y - center < 0 && y < viewWidth; y++)
            for(int x = 0; x < viewWidth; x++)
                networkInput[x * viewWidth + y] = -1;
        for(int x = viewWidth - 1; x + head.x - center >= xsize && x >= 0; x--)
            for(int y = 0; y < viewWidth; y++)
                networkInput[x * viewWidth + y] = -1;
        for(int y = viewWidth - 1; y + head.y - center >= ysize && y >= 0; y--)
            for(int x = 0; x < viewWidth; x++)
                networkInput[x * viewWidth + y] = -1;

        return networkInput;
    }

    private double[] createNetworkInputDistance(Point head, ArrayList<Point> tale, ArrayList<Point> food){
        double[] networkInput = new double[12];
        networkInput[0] = head.x;
        networkInput[1] = head.y;
        networkInput[2] = xsize - 1 - head.x;
        networkInput[3] = ysize - 1 - head.y;
        for(Point point : tale){
            double dist = point.distance(head);
            if(point.y == head.y){
                if(point.x < head.x){
                    if(networkInput[4] == 0 || dist < networkInput[4])
                        networkInput[4] = dist;
                }
                else{
                    if(networkInput[5] == 0 || dist < networkInput[5])
                        networkInput[5] = dist;
                }
            }
            else if(point.x == head.x){
                if(point.y < head.y){
                    if(networkInput[6] == 0 || dist < networkInput[6])
                        networkInput[6] = dist;
                }
                else{
                    if(networkInput[7] == 0 || dist < networkInput[7])
                        networkInput[7] = dist;
                }
            }
        }
        for(int a = 0; a < 4; a++){
            int x = a / 2 - 1;
            int y = a % 2 - 1;
            for(Point point : food) {
                double dist = point.distance(head.x + x,head.y + y);
                if (networkInput[a + 8] == 0 || dist < networkInput[a + 8])
                    networkInput[a + 8] = dist;
            }
        }
        for(int a = 4; a < 12; a++)
            networkInput[a] = networkInput[a] == 0 ? 1 : 1 / networkInput[a];
        return networkInput;
    }

    private void updateScreen(Point head, ArrayList<Point> tale, ArrayList<Point> food){
        Graphics2D graphics = this.screen.createGraphics();
        graphics.setColor(Color.WHITE);
        graphics.fillRect(0,0,this.screen.getWidth(),this.screen.getHeight());
        graphics.setColor(Color.BLACK);
        graphics.fillRect(1,1,this.screen.getWidth() - 2,this.screen.getHeight() - 2);
        graphics.setColor(Color.GREEN);
        graphics.fillRect(head.x + 1,head.y + 1,1,1);
        for(Point point : tale)
            graphics.fillRect(point.x + 1,point.y + 1,1,1);
        graphics.setColor(Color.RED);
        for(Point point : food)
            graphics.fillRect(point.x + 1,point.y + 1,1,1);
    }

    public static class Result {
        public final double score;
        public final int updates;
        public final int fitness;
        private Result(double score, int updates){
            this.score = score;
            this.updates = updates;
            this.fitness = (int)(score * 100 + updates);
//            if(score < 10)
//                this.fitness = (int)(Math.floor(updates * updates) * Math.pow(2,score));
//            else
//                this.fitness = (int)(Math.floor(updates * updates) * Math.pow(2,10) * (score - 9));
        }
    }

}
